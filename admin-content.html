<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Content Admin - Chomp Chomp</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #f5f5f5;
      color: #353535;
    }

    /* Login Screen */
    #loginScreen {
      display: none;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .login-box {
      background: white;
      padding: 40px;
      border-radius: 12px;
      max-width: 400px;
      width: 100%;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    }

    .login-box h2 {
      color: #e73b42;
      margin-bottom: 10px;
      font-size: 24px;
    }

    .login-box p {
      color: #666;
      margin-bottom: 25px;
      font-size: 14px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #353535;
    }

    .form-group input {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-size: 16px;
      font-family: inherit;
    }

    .form-group input:focus {
      outline: none;
      border-color: #e73b42;
    }

    button {
      background: #e73b42;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.2s;
      width: 100%;
    }

    button:hover {
      background: #d32f36;
      transform: translateY(-1px);
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    button.secondary {
      background: #666;
      width: auto;
    }

    button.secondary:hover {
      background: #555;
    }

    .login-error {
      color: #c62828;
      font-size: 14px;
      margin-top: 10px;
      padding: 10px;
      background: #ffebee;
      border-radius: 4px;
      display: none;
    }

    .login-error.show {
      display: block;
    }

    /* Main Admin Interface */
    #editorScreen {
      display: none;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    h1 {
      color: #e73b42;
      margin-bottom: 10px;
    }

    h2 {
      color: #353535;
      margin: 30px 0 15px 0;
      padding-bottom: 10px;
      border-bottom: 2px solid #e73b42;
    }

    .header-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .user-info {
      color: #666;
      font-size: 14px;
    }

    .tabs {
      display: flex;
      gap: 10px;
      margin: 20px 0;
      border-bottom: 2px solid #e0e0e0;
    }

    .tab {
      padding: 12px 24px;
      background: none;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 16px;
      color: #666;
      transition: all 0.2s;
    }

    .tab.active {
      color: #e73b42;
      border-bottom-color: #e73b42;
    }

    .tab:hover {
      color: #e73b42;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .actions {
      display: flex;
      gap: 10px;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 10px 14px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
    }

    .form-group textarea {
      min-height: 150px;
      font-family: 'Monaco', 'Courier New', monospace;
      resize: vertical;
    }

    .status {
      margin: 15px 0;
      padding: 12px;
      border-radius: 6px;
      display: none;
    }

    .status.success {
      background: #e7f7ed;
      color: #2e7d32;
      border: 1px solid #4caf50;
      display: block;
    }

    .status.error {
      background: #ffebee;
      color: #c62828;
      border: 1px solid #ef5350;
      display: block;
    }

    .status.info {
      background: #e3f2fd;
      color: #1565c0;
      border: 1px solid #2196f3;
      display: block;
    }

    .entry-list {
      margin: 20px 0;
      max-height: 600px;
      overflow-y: auto;
    }

    .entry-item {
      background: #f9f9f9;
      padding: 15px;
      margin: 10px 0;
      border-radius: 6px;
      border-left: 4px solid #e73b42;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    .entry-content {
      flex: 1;
    }

    .entry-content h3 {
      color: #e73b42;
      margin-bottom: 8px;
    }

    .entry-actions {
      display: flex;
      gap: 8px;
    }

    .entry-actions button {
      padding: 6px 12px;
      font-size: 14px;
      width: auto;
    }
  </style>
</head>
<body>

  <!-- Login Screen -->
  <div id="loginScreen">
    <div class="login-box">
      <h2>Admin Login</h2>
      <p>Sign in to manage lexicon and reading list</p>

      <form onsubmit="handleLogin(event)">
        <div class="form-group">
          <label>Email</label>
          <input type="email" id="loginEmail" required autofocus>
        </div>

        <div class="form-group">
          <label>Password</label>
          <input type="password" id="loginPassword" required>
        </div>

        <button type="submit">Sign In</button>
      </form>

      <div id="loginError" class="login-error"></div>
    </div>
  </div>

  <!-- Main Admin Content -->
  <div id="editorScreen">
    <div class="container">
      <div class="header-bar">
        <div>
          <h1>Content Admin</h1>
          <p style="color: #666; margin: 0;">Manage Lexicon & Reading List</p>
        </div>
        <div>
          <span class="user-info" id="userEmail"></span>
          <button class="secondary" onclick="handleLogout()" style="margin-left: 15px;">Logout</button>
        </div>
      </div>

      <div class="tabs">
        <button class="tab active" onclick="switchTab('lexicon')">Lexicon</button>
        <button class="tab" onclick="switchTab('books')">Reading List</button>
        <button class="tab" onclick="switchTab('bulk')">Bulk Upload</button>
      </div>

      <!-- LEXICON TAB -->
      <div id="lexicon" class="tab-content active">
        <h2>Add New Term</h2>
        <form id="lexiconForm" onsubmit="saveLexiconEntry(event)">
          <div class="form-group">
            <label>Term Name *</label>
            <input type="text" id="termName" required>
          </div>

          <div class="form-group">
            <label>Type *</label>
            <select id="termType" required>
              <option value="ingredient">Ingredient</option>
              <option value="technique">Technique</option>
              <option value="concept">Concept</option>
            </select>
          </div>

          <div class="form-group">
            <label>Description *</label>
            <textarea id="termDescription" required></textarea>
          </div>

          <div class="form-group">
            <label>Image URL (optional)</label>
            <input type="url" id="termImage" placeholder="https://...">
          </div>

          <div class="actions">
            <button type="submit">Save Term</button>
            <button type="button" class="secondary" onclick="clearLexiconForm()">Clear</button>
          </div>
        </form>

        <div id="lexiconStatus" class="status"></div>

        <h2>Existing Terms</h2>
        <div class="actions">
          <button onclick="loadLexicon()">Refresh List</button>
        </div>
        <div id="lexiconList" class="entry-list"></div>
      </div>

      <!-- BOOKS TAB -->
      <div id="books" class="tab-content">
        <h2>Add New Book</h2>
        <form id="bookForm" onsubmit="saveBookEntry(event)">
          <div class="form-group">
            <label>ISBN *</label>
            <input type="text" id="bookISBN" required placeholder="9781234567890">
          </div>

          <div class="actions" style="margin-top: 10px; margin-bottom: 20px;">
            <button type="button" class="secondary" onclick="fetchBookFromISBN()">Fetch Data from ISBN</button>
          </div>

          <div class="form-group">
            <label>Title *</label>
            <input type="text" id="bookTitle" required>
          </div>

          <div class="form-group">
            <label>Author(s) *</label>
            <input type="text" id="bookAuthors" required>
          </div>

          <div class="form-group">
            <label>Publisher</label>
            <input type="text" id="bookPublisher">
          </div>

          <div class="form-group">
            <label>Publication Date</label>
            <input type="text" id="bookPubDate" placeholder="2024">
          </div>

          <div class="form-group">
            <label>Cover Image URL</label>
            <input type="url" id="bookCover" placeholder="https://...">
          </div>

          <div class="form-group">
            <label>LC Call Number</label>
            <input type="text" id="bookLCCallNumber" placeholder="TX763 .F63 2008">
          </div>

          <div class="form-group">
            <label>Your Notes (Markdown supported)</label>
            <textarea id="bookNotes"></textarea>
          </div>

          <div class="form-group">
            <label>
              <input type="checkbox" id="bookRecommended">
              Mark as Recommended
            </label>
          </div>

          <div class="actions">
            <button type="submit">Save Book</button>
            <button type="button" class="secondary" onclick="clearBookForm()">Clear</button>
          </div>
        </form>

        <div id="bookStatus" class="status"></div>

        <h2>Existing Books</h2>
        <div class="actions">
          <button onclick="loadBooks()">Refresh List</button>
          <button onclick="refreshLCData()" class="secondary">Refresh LC Call Numbers</button>
        </div>
        <div id="lcRefreshStatus" class="status"></div>
        <div id="bookList" class="entry-list"></div>
      </div>

      <!-- BULK UPLOAD TAB -->
      <div id="bulk" class="tab-content">
        <h2>Bulk Upload Lexicon Terms</h2>
        <p style="color:#666;margin-bottom:15px;">Paste your lexicon data in the format below. Each entry should be separated by a blank line.</p>
        <p style="color:#666;margin-bottom:15px;font-family:monospace;font-size:0.9em;">
          Term: [Name]<br>
          Type: [ingredient|technique|concept]<br>
          Description: [Text]<br>
          Image: [URL or leave blank]
        </p>

        <div class="form-group">
          <label>Lexicon Data</label>
          <textarea id="bulkLexiconInput" style="min-height:300px;font-family:monospace;" placeholder="Term: Salt&#10;Type: ingredient&#10;Description: Enhances flavor...&#10;Image:&#10;&#10;Term: Lamination&#10;Type: technique&#10;Description: Folding butter...&#10;Image: https://..."></textarea>
        </div>

        <div class="actions">
          <button onclick="parseBulkLexicon()">Parse & Preview</button>
          <button class="secondary" onclick="uploadBulkLexicon()" id="uploadLexiconBtn" disabled>Upload All Terms</button>
        </div>

        <div id="bulkLexiconStatus" class="status"></div>
        <div id="bulkLexiconPreview"></div>

        <hr style="margin:40px 0;border:none;border-top:2px solid #e0e0e0;">

        <h2>Bulk Upload Books (from ISBNs)</h2>
        <p style="color:#666;margin-bottom:15px;">Paste ISBNs (one per line). Click "Fetch" to retrieve book data from Open Library API.</p>

        <div class="form-group">
          <label>ISBNs (one per line)</label>
          <textarea id="bulkISBNInput" style="min-height:200px;font-family:monospace;" placeholder="9781234567890&#10;9780987654321&#10;9781111111111"></textarea>
        </div>

        <div class="actions">
          <button onclick="fetchBulkBooks()">Fetch Book Data</button>
          <button class="secondary" onclick="uploadBulkBooks()" id="uploadBooksBtn" disabled>Upload All Books</button>
        </div>

        <div id="bulkBooksStatus" class="status"></div>
        <div id="bulkBooksProgress" style="margin:15px 0;padding:10px;background:#f0f0f0;border-radius:4px;font-family:monospace;font-size:12px;max-height:300px;overflow-y:auto;display:none;"></div>
        <div id="bulkBooksPreview"></div>
      </div>

    </div>
  </div>

  <!-- Firebase SDK -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, doc, setDoc, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyCCPb87ZtJbpI7YRRwKVNL-g3O-VrONwtM",
      authDomain: "chomp-chomp-recipes.firebaseapp.com",
      projectId: "chomp-chomp-recipes",
      storageBucket: "chomp-chomp-recipes.firebasestorage.app",
      messagingSenderId: "225432495618",
      appId: "1:225432495618:web:459eb1c0b7228dfc24e91b"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const appId = firebaseConfig.projectId;

    let currentUser = null;

    // Check authentication state
    onAuthStateChanged(auth, (user) => {
      if (user) {
        currentUser = user;
        document.getElementById('loginScreen').style.display = 'none';
        document.getElementById('editorScreen').style.display = 'block';
        document.getElementById('userEmail').textContent = user.email;
        loadLexicon();
        loadBooks();
      } else {
        currentUser = null;
        document.getElementById('loginScreen').style.display = 'flex';
        document.getElementById('editorScreen').style.display = 'none';
      }
    });

    // Handle login
    window.handleLogin = async function(event) {
      event.preventDefault();
      const email = document.getElementById('loginEmail').value;
      const password = document.getElementById('loginPassword').value;
      const errorDiv = document.getElementById('loginError');

      try {
        await signInWithEmailAndPassword(auth, email, password);
        errorDiv.classList.remove('show');
      } catch (error) {
        console.error("Login error:", error);
        errorDiv.classList.add('show');

        if (error.code === 'auth/user-not-found') {
          errorDiv.textContent = 'No user found with this email.';
        } else if (error.code === 'auth/wrong-password') {
          errorDiv.textContent = 'Incorrect password.';
        } else if (error.code === 'auth/invalid-email') {
          errorDiv.textContent = 'Invalid email address.';
        } else {
          errorDiv.textContent = 'Login failed: ' + error.message;
        }
      }
    }

    // Handle logout
    window.handleLogout = async function() {
      if (confirm('Are you sure you want to logout?')) {
        await signOut(auth);
      }
    }

    // Make functions global
    window.switchTab = switchTab;
    window.saveLexiconEntry = saveLexiconEntry;
    window.saveBookEntry = saveBookEntry;
    window.clearLexiconForm = clearLexiconForm;
    window.clearBookForm = clearBookForm;
    window.loadLexicon = loadLexicon;
    window.loadBooks = loadBooks;
    window.fetchBookFromISBN = fetchBookFromISBN;
    window.editLexiconEntry = editLexiconEntry;
    window.deleteLexiconEntry = deleteLexiconEntry;
    window.editBookEntry = editBookEntry;
    window.deleteBookEntry = deleteBookEntry;
    window.parseBulkLexicon = parseBulkLexicon;
    window.uploadBulkLexicon = uploadBulkLexicon;
    window.fetchBulkBooks = fetchBulkBooks;
    window.uploadBulkBooks = uploadBulkBooks;

    let parsedBulkLexicon = [];
    let fetchedBulkBooks = [];

    // Tab switching
    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      event.target.classList.add('active');
      document.getElementById(tabName).classList.add('active');
    }

    // Helper functions
    function generateSlug(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .trim();
    }

    function showStatus(type, message, status) {
      const statusEl = document.getElementById(type + 'Status');
      statusEl.className = 'status ' + status;
      statusEl.textContent = message;
      setTimeout(() => {
        if (status !== 'error') {
          statusEl.className = 'status';
        }
      }, 5000);
    }

    // === LEXICON FUNCTIONS ===

    async function saveLexiconEntry(event) {
      event.preventDefault();

      const term = document.getElementById('termName').value.trim();
      const type = document.getElementById('termType').value;
      const description = document.getElementById('termDescription').value.trim();
      const image = document.getElementById('termImage').value.trim();

      const entry = {
        term,
        slug: generateSlug(term),
        type,
        description,
        image: image || null,
        dateAdded: new Date().toISOString()
      };

      try {
        await setDoc(doc(db, `artifacts/${appId}/public/data/lexicon`, entry.slug), entry);
        showStatus('lexicon', 'Term saved successfully!', 'success');
        clearLexiconForm();
        loadLexicon();
      } catch (error) {
        showStatus('lexicon', 'Error saving term: ' + error.message, 'error');
      }
    }

    function clearLexiconForm() {
      document.getElementById('lexiconForm').reset();
    }

    async function loadLexicon() {
      try {
        const lexiconRef = collection(db, `artifacts/${appId}/public/data/lexicon`);
        const snapshot = await getDocs(lexiconRef);
        const entries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        entries.sort((a, b) => a.term.localeCompare(b.term));

        const list = document.getElementById('lexiconList');
        if (entries.length === 0) {
          list.innerHTML = '<p style="text-align:center;color:#999;padding:40px;">No entries yet.</p>';
          return;
        }

        list.innerHTML = entries.map(entry => `
          <div class="entry-item">
            <div class="entry-content">
              <h3>${entry.term}</h3>
              <div style="color:#666;font-size:0.9em;margin-bottom:8px;">Type: ${entry.type}</div>
              <div style="font-size:0.95em;line-height:1.6;">${entry.description.substring(0, 150)}...</div>
            </div>
            <div class="entry-actions">
              <button class="secondary" onclick="editLexiconEntry('${entry.id}')">Edit</button>
              <button class="secondary" onclick="deleteLexiconEntry('${entry.id}', '${entry.term.replace(/'/g, "\\'")}')">Delete</button>
            </div>
          </div>
        `).join('');
      } catch (error) {
        showStatus('lexicon', 'Error loading terms: ' + error.message, 'error');
      }
    }

    async function editLexiconEntry(id) {
      try {
        const lexiconRef = collection(db, `artifacts/${appId}/public/data/lexicon`);
        const snapshot = await getDocs(lexiconRef);
        const entry = snapshot.docs.find(doc => doc.id === id)?.data();

        if (entry) {
          document.getElementById('termName').value = entry.term;
          document.getElementById('termType').value = entry.type;
          document.getElementById('termDescription').value = entry.description;
          document.getElementById('termImage').value = entry.image || '';
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
      } catch (error) {
        showStatus('lexicon', 'Error loading term: ' + error.message, 'error');
      }
    }

    async function deleteLexiconEntry(id, name) {
      if (!confirm(`Delete "${name}"?`)) return;

      try {
        await deleteDoc(doc(db, `artifacts/${appId}/public/data/lexicon`, id));
        showStatus('lexicon', 'Term deleted successfully', 'success');
        loadLexicon();
      } catch (error) {
        showStatus('lexicon', 'Error deleting term: ' + error.message, 'error');
      }
    }

    // === BOOKS FUNCTIONS ===

    async function fetchBookFromISBN() {
      const isbn = document.getElementById('bookISBN').value.trim();
      if (!isbn) return;

      showStatus('book', 'Fetching book data...', 'info');

      try {
        const response = await fetch(`https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&format=json&jscmd=data`);
        const data = await response.json();
        const bookKey = `ISBN:${isbn}`;

        if (data[bookKey]) {
          const book = data[bookKey];
          document.getElementById('bookTitle').value = book.title || '';
          document.getElementById('bookAuthors').value = book.authors ? book.authors.map(a => a.name).join(', ') : '';
          document.getElementById('bookPublisher').value = book.publishers ? book.publishers[0].name : '';
          document.getElementById('bookPubDate').value = book.publish_date || '';
          document.getElementById('bookCover').value = book.cover?.large || book.cover?.medium || book.cover?.small || '';

          // Try to get LC classification - first from books API, then from ISBN endpoint
          let lcCallNumber = book.lc_classifications && book.lc_classifications.length > 0
            ? book.lc_classifications[0]
            : '';

          if (!lcCallNumber) {
            try {
              const isbnResponse = await fetch(`https://openlibrary.org/isbn/${isbn}.json`);
              if (isbnResponse.ok) {
                const isbnData = await isbnResponse.json();
                if (isbnData.classifications && isbnData.classifications.lc_classifications) {
                  lcCallNumber = Array.isArray(isbnData.classifications.lc_classifications)
                    ? isbnData.classifications.lc_classifications[0]
                    : isbnData.classifications.lc_classifications;
                }
              }
            } catch (err) {
              // Silently fail - LC data is optional
            }
          }

          document.getElementById('bookLCCallNumber').value = lcCallNumber;
          showStatus('book', 'Book data fetched successfully!' + (lcCallNumber ? ' (LC# found)' : ''), 'success');
        } else {
          showStatus('book', 'No data found for this ISBN', 'error');
        }
      } catch (error) {
        showStatus('book', 'Error fetching book: ' + error.message, 'error');
      }
    }

    async function saveBookEntry(event) {
      event.preventDefault();

      const isbn = document.getElementById('bookISBN').value.trim();
      const title = document.getElementById('bookTitle').value.trim();
      const authors = document.getElementById('bookAuthors').value.trim();
      const publisher = document.getElementById('bookPublisher').value.trim();
      const publicationDate = document.getElementById('bookPubDate').value.trim();
      const coverImage = document.getElementById('bookCover').value.trim();
      const lcCallNumber = document.getElementById('bookLCCallNumber').value.trim();
      const yourNotes = document.getElementById('bookNotes').value.trim();
      const recommended = document.getElementById('bookRecommended').checked;

      const entry = {
        isbn,
        title,
        authors,
        publisher: publisher || null,
        publicationDate: publicationDate || null,
        coverImage: coverImage || null,
        lcCallNumber: lcCallNumber || null,
        yourNotes: yourNotes || '',
        recommended,
        slug: generateSlug(title),
        dateAdded: new Date().toISOString()
      };

      try {
        await setDoc(doc(db, `artifacts/${appId}/public/data/reading-list`, entry.slug), entry);
        showStatus('book', 'Book saved successfully!', 'success');
        clearBookForm();
        loadBooks();
      } catch (error) {
        showStatus('book', 'Error saving book: ' + error.message, 'error');
      }
    }

    function clearBookForm() {
      document.getElementById('bookForm').reset();
    }

    async function loadBooks() {
      try {
        const booksRef = collection(db, `artifacts/${appId}/public/data/reading-list`);
        const snapshot = await getDocs(booksRef);
        const books = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        books.sort((a, b) => a.title.localeCompare(b.title));

        const list = document.getElementById('bookList');
        if (books.length === 0) {
          list.innerHTML = '<p style="text-align:center;color:#999;padding:40px;">No books yet.</p>';
          return;
        }

        list.innerHTML = books.map(book => `
          <div class="entry-item">
            <div class="entry-content">
              <h3>${book.title}</h3>
              <div style="color:#666;font-size:0.9em;margin-bottom:8px;">${book.authors} ${book.recommended ? '★' : ''}</div>
              <div style="font-size:0.85em;color:#999;">${book.publisher || ''} ${book.publicationDate || ''}</div>
              ${book.lcCallNumber ? `<div style="font-size:0.85em;color:#e73b42;font-weight:500;margin-top:4px;">LC: ${book.lcCallNumber}</div>` : ''}
            </div>
            <div class="entry-actions">
              <button class="secondary" onclick="editBookEntry('${book.id}')">Edit</button>
              <button class="secondary" onclick="deleteBookEntry('${book.id}', '${book.title.replace(/'/g, "\\'")}')">Delete</button>
            </div>
          </div>
        `).join('');
      } catch (error) {
        showStatus('book', 'Error loading books: ' + error.message, 'error');
      }
    }

    async function editBookEntry(id) {
      try {
        const booksRef = collection(db, `artifacts/${appId}/public/data/reading-list`);
        const snapshot = await getDocs(booksRef);
        const book = snapshot.docs.find(doc => doc.id === id)?.data();

        if (book) {
          document.getElementById('bookISBN').value = book.isbn;
          document.getElementById('bookTitle').value = book.title;
          document.getElementById('bookAuthors').value = book.authors;
          document.getElementById('bookPublisher').value = book.publisher || '';
          document.getElementById('bookPubDate').value = book.publicationDate || '';
          document.getElementById('bookCover').value = book.coverImage || '';
          document.getElementById('bookLCCallNumber').value = book.lcCallNumber || '';
          document.getElementById('bookNotes').value = book.yourNotes || '';
          document.getElementById('bookRecommended').checked = book.recommended || false;
          window.scrollTo({ top: 0, behavior: 'smooth' });

          // Switch to books tab
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          document.querySelector('.tab:nth-child(2)').classList.add('active');
          document.getElementById('books').classList.add('active');
        }
      } catch (error) {
        showStatus('book', 'Error loading book: ' + error.message, 'error');
      }
    }

    async function deleteBookEntry(id, title) {
      if (!confirm(`Delete "${title}"?`)) return;

      try {
        await deleteDoc(doc(db, `artifacts/${appId}/public/data/reading-list`, id));
        showStatus('book', 'Book deleted successfully', 'success');
        loadBooks();
      } catch (error) {
        showStatus('book', 'Error deleting book: ' + error.message, 'error');
      }
    }

    // === BULK UPLOAD FUNCTIONS ===

    function parseBulkLexicon() {
      const input = document.getElementById('bulkLexiconInput').value.trim();
      if (!input) {
        showStatus('bulkLexicon', 'Please paste lexicon data first', 'error');
        return;
      }

      try {
        parsedBulkLexicon = [];
        const entries = input.split('\n\n').filter(e => e.trim());

        entries.forEach(entry => {
          const lines = entry.split('\n');
          const term = {};

          lines.forEach(line => {
            if (line.startsWith('Term: ')) term.term = line.replace('Term: ', '').trim();
            if (line.startsWith('Type: ')) term.type = line.replace('Type: ', '').trim().toLowerCase();
            if (line.startsWith('Description: ')) term.description = line.replace('Description: ', '').trim();
            if (line.startsWith('Image: ')) {
              const img = line.replace('Image: ', '').trim();
              term.image = img || null;
            }
          });

          if (term.term && term.description) {
            term.slug = generateSlug(term.term);
            term.dateAdded = new Date().toISOString();
            parsedBulkLexicon.push(term);
          }
        });

        showStatus('bulkLexicon', `Parsed ${parsedBulkLexicon.length} entries successfully!`, 'success');

        // Display preview
        const preview = document.getElementById('bulkLexiconPreview');
        preview.innerHTML = `<h3 style="margin-top:20px;">Preview (${parsedBulkLexicon.length} entries)</h3>` +
          parsedBulkLexicon.map(entry => `
            <div class="entry-item">
              ${entry.image ? `<img src="${entry.image}" alt="${entry.term}" style="width:100px;height:100px;object-fit:cover;border-radius:6px;margin-right:15px;">` : ''}
              <div class="entry-content">
                <h3>${entry.term}</h3>
                <div style="color:#666;font-size:0.9em;margin-bottom:8px;">Type: ${entry.type}</div>
                <div style="font-size:0.95em;line-height:1.6;">${entry.description.substring(0, 150)}...</div>
              </div>
            </div>
          `).join('');

        document.getElementById('uploadLexiconBtn').disabled = false;
      } catch (error) {
        showStatus('bulkLexicon', 'Parse error: ' + error.message, 'error');
      }
    }

    async function uploadBulkLexicon() {
      if (parsedBulkLexicon.length === 0) {
        showStatus('bulkLexicon', 'No data to upload. Parse first!', 'error');
        return;
      }

      const btn = document.getElementById('uploadLexiconBtn');
      btn.disabled = true;

      try {
        const lexiconRef = collection(db, `artifacts/${appId}/public/data/lexicon`);

        for (let entry of parsedBulkLexicon) {
          await setDoc(doc(lexiconRef, entry.slug), entry);
        }

        showStatus('bulkLexicon', `Successfully uploaded ${parsedBulkLexicon.length} entries!`, 'success');
        document.getElementById('bulkLexiconInput').value = '';
        document.getElementById('bulkLexiconPreview').innerHTML = '';
        parsedBulkLexicon = [];
        loadLexicon();
      } catch (error) {
        showStatus('bulkLexicon', 'Upload error: ' + error.message, 'error');
      } finally {
        btn.disabled = false;
      }
    }

    async function fetchBulkBooks() {
      const input = document.getElementById('bulkISBNInput').value.trim();
      if (!input) {
        showStatus('bulkBooks', 'Please paste ISBNs first', 'error');
        return;
      }

      const isbns = input.split('\n').map(i => i.trim()).filter(i => i);
      const btn = document.getElementById('uploadBooksBtn');
      const progress = document.getElementById('bulkBooksProgress');

      progress.style.display = 'block';
      progress.innerHTML = `<div>Fetching data for ${isbns.length} books...</div>`;

      fetchedBulkBooks = [];

      for (let isbn of isbns) {
        try {
          progress.innerHTML += `<div>⏳ Fetching ${isbn}...</div>`;

          const response = await fetch(`https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&format=json&jscmd=data`);
          const data = await response.json();

          const bookKey = `ISBN:${isbn}`;
          if (data[bookKey]) {
            const book = data[bookKey];

            let coverImage = book.cover?.large || book.cover?.medium || book.cover?.small || null;

            // If no cover from Open Library, try Google Books API
            if (!coverImage) {
              try {
                progress.innerHTML += `<div>   → Trying Google Books for cover...</div>`;
                const gbResponse = await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`);
                const gbData = await gbResponse.json();

                if (gbData.items && gbData.items[0]) {
                  const volumeInfo = gbData.items[0].volumeInfo;
                  if (volumeInfo.imageLinks) {
                    coverImage = volumeInfo.imageLinks.large ||
                                volumeInfo.imageLinks.medium ||
                                volumeInfo.imageLinks.thumbnail ||
                                volumeInfo.imageLinks.smallThumbnail ||
                                null;
                  }
                }
              } catch (gbError) {
                // Silently fail - just won't have a cover
              }
            }

            // Try to get LC classification from direct ISBN endpoint
            let lcCallNumber = book.lc_classifications && book.lc_classifications.length > 0
              ? book.lc_classifications[0]
              : null;
            let lccn = book.lccn && book.lccn.length > 0 ? book.lccn[0] : null;

            if (!lcCallNumber) {
              try {
                const isbnResponse = await fetch(`https://openlibrary.org/isbn/${isbn}.json`);
                if (isbnResponse.ok) {
                  const isbnData = await isbnResponse.json();
                  if (isbnData.classifications && isbnData.classifications.lc_classifications) {
                    lcCallNumber = Array.isArray(isbnData.classifications.lc_classifications)
                      ? isbnData.classifications.lc_classifications[0]
                      : isbnData.classifications.lc_classifications;
                  }
                  if (!lccn && isbnData.lccn) {
                    lccn = Array.isArray(isbnData.lccn) ? isbnData.lccn[0] : isbnData.lccn;
                  }
                }
              } catch (err) {
                // Silently fail - LC data is optional
              }
            }

            const bookData = {
              isbn: isbn,
              title: book.title || 'Unknown Title',
              subtitle: book.subtitle || null,
              authors: book.authors ? book.authors.map(a => a.name).join(', ') : 'Unknown Author',
              publisher: book.publishers ? book.publishers.map(p => p.name).join(', ') : null,
              publicationDate: book.publish_date || null,
              pages: book.number_of_pages || null,
              subjects: book.subjects ? book.subjects.map(s => typeof s === 'object' ? s.name : s) : [],
              subjectLinks: book.subjects ? book.subjects.filter(s => s.url).map(s => ({ name: s.name, url: s.url })) : [],
              lcCallNumber: lcCallNumber,
              lccn: lccn,
              description: book.notes || null,
              coverImage: coverImage,
              slug: generateSlug(book.title),
              yourNotes: '',
              yourTags: [],
              recommended: false,
              inYourLibrary: false,
              dateAdded: new Date().toISOString()
            };

            fetchedBulkBooks.push(bookData);
            const coverInfo = coverImage ? ' | cover ✓' : ' | no cover';
            const lcInfo = bookData.lcCallNumber ? ' | LC# ✓' : ' | no LC#';
            progress.innerHTML += `<div>✓ Found: ${bookData.title}${coverInfo}${lcInfo}</div>`;
          } else {
            progress.innerHTML += `<div>⚠️ No data found for ${isbn}</div>`;
          }

          // Rate limiting
          await new Promise(resolve => setTimeout(resolve, 1000));
        } catch (error) {
          progress.innerHTML += `<div>❌ Error with ${isbn}: ${error.message}</div>`;
        }
      }

      showStatus('bulkBooks', `Fetched ${fetchedBulkBooks.length} of ${isbns.length} books`, 'success');

      // Display preview
      const preview = document.getElementById('bulkBooksPreview');
      preview.innerHTML = `<h3 style="margin-top:20px;">Preview (${fetchedBulkBooks.length} books)</h3>` +
        '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:15px;margin-top:15px;">' +
        fetchedBulkBooks.map(book => `
          <div style="background:#f9f9f9;padding:10px;border-radius:6px;font-size:0.85em;">
            ${book.coverImage ? `<img src="${book.coverImage}" alt="${book.title}" style="width:100%;height:200px;object-fit:cover;border-radius:4px;margin-bottom:10px;">` : '<div style="width:100%;height:200px;background:#e0e0e0;border-radius:4px;margin-bottom:10px;display:flex;align-items:center;justify-content:center;color:#999;">No Cover</div>'}
            <strong>${book.title}</strong><br>
            <span style="color:#666;">${book.authors}</span><br>
            <span style="color:#999;font-size:0.9em;">${book.publisher || ''} ${book.publicationDate || ''}</span>
          </div>
        `).join('') + '</div>';

      btn.disabled = false;
    }

    async function uploadBulkBooks() {
      if (fetchedBulkBooks.length === 0) {
        showStatus('bulkBooks', 'No data to upload. Fetch first!', 'error');
        return;
      }

      const btn = document.getElementById('uploadBooksBtn');
      btn.disabled = true;

      try {
        const booksRef = collection(db, `artifacts/${appId}/public/data/reading-list`);

        for (let book of fetchedBulkBooks) {
          await setDoc(doc(booksRef, book.slug), book);
        }

        showStatus('bulkBooks', `Successfully uploaded ${fetchedBulkBooks.length} books!`, 'success');
        document.getElementById('bulkISBNInput').value = '';
        document.getElementById('bulkBooksPreview').innerHTML = '';
        document.getElementById('bulkBooksProgress').style.display = 'none';
        fetchedBulkBooks = [];
        loadBooks();
      } catch (error) {
        showStatus('bulkBooks', 'Upload error: ' + error.message, 'error');
      } finally {
        btn.disabled = false;
      }
    }

    // Refresh LC Call Numbers for existing books
    async function refreshLCData() {
      const statusDiv = document.getElementById('lcRefreshStatus');
      statusDiv.innerHTML = '<div style="padding:15px;background:#e3f2fd;border-radius:6px;margin:15px 0;">Starting LC data refresh...</div>';

      try {
        // Get all existing books
        const booksRef = collection(db, `artifacts/${appId}/public/data/reading-list`);
        const snapshot = await getDocs(booksRef);
        const books = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        let updated = 0;
        let skipped = 0;
        let errors = 0;

        statusDiv.innerHTML += `<div>Found ${books.length} books. Checking for LC data...</div>`;

        for (let book of books) {
          if (!book.isbn) {
            statusDiv.innerHTML += `<div style="color:#999;">⊘ Skipped "${book.title}" (no ISBN)</div>`;
            skipped++;
            continue;
          }

          // Check if already has LC call number
          if (book.lcCallNumber) {
            statusDiv.innerHTML += `<div style="color:#999;">⊘ Skipped "${book.title}" (already has LC#: ${book.lcCallNumber})</div>`;
            skipped++;
            continue;
          }

          try {
            statusDiv.innerHTML += `<div>⏳ Fetching LC data for "${book.title}"...</div>`;

            // Try direct ISBN endpoint first for LC classifications
            let lcCallNumber = null;
            let lccn = null;

            try {
              const isbnResponse = await fetch(`https://openlibrary.org/isbn/${book.isbn}.json`);
              if (isbnResponse.ok) {
                const isbnData = await isbnResponse.json();

                // Check for LC classifications
                if (isbnData.classifications) {
                  if (isbnData.classifications.lc_classifications) {
                    lcCallNumber = Array.isArray(isbnData.classifications.lc_classifications)
                      ? isbnData.classifications.lc_classifications[0]
                      : isbnData.classifications.lc_classifications;
                  }
                }

                // Check for LCCN
                if (isbnData.lccn) {
                  lccn = Array.isArray(isbnData.lccn) ? isbnData.lccn[0] : isbnData.lccn;
                }

                statusDiv.innerHTML += `<div style="color:#666;">   → Direct ISBN API: ${lcCallNumber ? 'LC# found' : 'no LC data'}</div>`;
              }
            } catch (err) {
              statusDiv.innerHTML += `<div style="color:#999;">   → Direct ISBN API failed, trying alternate...</div>`;
            }

            // If no LC data from direct endpoint, try the books API
            if (!lcCallNumber) {
              try {
                const response = await fetch(`https://openlibrary.org/api/books?bibkeys=ISBN:${book.isbn}&format=json&jscmd=details`);
                const data = await response.json();
                const bookKey = `ISBN:${book.isbn}`;

                if (data[bookKey] && data[bookKey].details) {
                  const details = data[bookKey].details;

                  if (details.classifications) {
                    if (details.classifications.lc_classifications) {
                      lcCallNumber = Array.isArray(details.classifications.lc_classifications)
                        ? details.classifications.lc_classifications[0]
                        : details.classifications.lc_classifications;
                    }
                  }

                  if (!lccn && details.lccn) {
                    lccn = Array.isArray(details.lccn) ? details.lccn[0] : details.lccn;
                  }

                  statusDiv.innerHTML += `<div style="color:#666;">   → Books API: ${lcCallNumber ? 'LC# found' : 'no LC data'}</div>`;
                }
              } catch (err) {
                statusDiv.innerHTML += `<div style="color:#999;">   → Books API also failed</div>`;
              }
            }

            if (lcCallNumber || lccn) {
              // Update book in Firestore
              await setDoc(doc(booksRef, book.id), {
                ...book,
                lcCallNumber: lcCallNumber,
                lccn: lccn
              }, { merge: true });

              statusDiv.innerHTML += `<div style="color:#2e7d32;">✓ Updated "${book.title}" ${lcCallNumber ? `(LC#: ${lcCallNumber})` : '(LCCN only)'}</div>`;
              updated++;
            } else {
              statusDiv.innerHTML += `<div style="color:#f57c00;">⚠ No LC data available for "${book.title}"</div>`;
              skipped++;
            }

            // Rate limiting
            await new Promise(resolve => setTimeout(resolve, 1000));
          } catch (error) {
            statusDiv.innerHTML += `<div style="color:#c62828;">❌ Error fetching "${book.title}": ${error.message}</div>`;
            errors++;
          }
        }

        statusDiv.innerHTML += `<div style="margin-top:15px;padding:15px;background:#e8f5e9;border-radius:6px;"><strong>Refresh Complete!</strong><br>Updated: ${updated} | Skipped: ${skipped} | Errors: ${errors}</div>`;

        // Reload book list
        if (updated > 0) {
          loadBooks();
        }
      } catch (error) {
        statusDiv.innerHTML += `<div style="color:#c62828;padding:15px;background:#ffebee;border-radius:6px;margin:15px 0;">Error: ${error.message}</div>`;
      }
    }
  </script>

</body>
</html>
